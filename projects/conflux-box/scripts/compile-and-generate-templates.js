#!/usr/bin/env node
import fs from "fs";
import path from "path";
import solc from "solc";

// Simple script to compile Solidity contracts in scripts/contracts and
// generate a TypeScript module exporting ABI and runtime bytecode for the UI templates.

const contractsDir = path.resolve(process.cwd(), "scripts/contracts");
const outFile = path.resolve(
  process.cwd(),
  "src/data/generatedContractTemplates.ts"
);

function readSources() {
  const files = fs.readdirSync(contractsDir).filter((f) => f.endsWith(".sol"));
  const sources = {};
  for (const file of files) {
    const content = fs.readFileSync(path.join(contractsDir, file), "utf8");
    sources[file] = { content };
  }
  return sources;
}

async function compile(sources, solcVersion = null) {
  // Use Solidity 0.8.18 to avoid PUSH0 opcode issues with DevKit
  let compiler = solc;
  if (solcVersion) {
    console.log(`Loading Solidity compiler version ${solcVersion}...`);
    compiler = await new Promise((resolve, reject) => {
      solc.loadRemoteVersion(solcVersion, (err, solcSnapshot) => {
        if (err) reject(err);
        else resolve(solcSnapshot);
      });
    });
  }

  const input = {
    language: "Solidity",
    sources,
    settings: {
      optimizer: { enabled: true, runs: 200 },
      outputSelection: {
        "*": {
          "*": ["abi", "evm.deployedBytecode", "evm.bytecode"],
        },
      },
    },
  };

  const output = JSON.parse(compiler.compile(JSON.stringify(input)));
  if (output.errors) {
    // Print errors/warnings
    const errors = output.errors.filter((e) => e.severity === "error");
    const warnings = output.errors.filter((e) => e.severity === "warning");
    for (const w of warnings) console.warn("Warning:", w.formattedMessage);
    if (errors.length) {
      for (const e of errors) console.error("Error:", e.formattedMessage);
      throw new Error("Compilation failed");
    }
  }
  return output.contracts;
}

function pickRuntimeBytecode(contractsOutput) {
  const results = {};
  for (const file of Object.keys(contractsOutput)) {
    for (const contractName of Object.keys(contractsOutput[file])) {
      const contract = contractsOutput[file][contractName];
      const abi = contract.abi || [];
      let runtimeBytecode =
        (contract.evm &&
          contract.evm.deployedBytecode &&
          contract.evm.deployedBytecode.object) ||
        "";
      let fullBytecode =
        (contract.evm &&
          contract.evm.bytecode &&
          contract.evm.bytecode.object) ||
        "";
      if (runtimeBytecode && !runtimeBytecode.startsWith("0x"))
        runtimeBytecode = "0x" + runtimeBytecode;
      if (fullBytecode && !fullBytecode.startsWith("0x"))
        fullBytecode = "0x" + fullBytecode;
      results[contractName] = { abi, runtimeBytecode, fullBytecode };
    }
  }
  return results;
}

function generateTsModule(results) {
  const lines = [];
  lines.push(
    "// This file is generated by scripts/compile-and-generate-templates.js"
  );
  lines.push("// Do not edit by hand.");
  lines.push("");
  lines.push("export const generatedContractTemplates = {");
  for (const [name, artifact] of Object.entries(results)) {
    const safeName = name.replace(/[^a-zA-Z0-9_]/g, "_");
    lines.push(`  \"${safeName}\": {`);
    lines.push(`    abi: ${JSON.stringify(artifact.abi, null, 2)},`);
    lines.push(`    runtimeBytecode: \"${artifact.runtimeBytecode}\",`);
    lines.push(`    fullBytecode: \"${artifact.fullBytecode}\"`);
    lines.push("  },");
  }
  lines.push("} as const;");
  return lines.join("\n");
}

async function main() {
  console.log("Compiling contracts in", contractsDir);
  const sources = readSources();
  const contractsOutput = await compile(sources, "v0.8.18+commit.87f61d96");
  const results = pickRuntimeBytecode(contractsOutput);
  const tsModule = generateTsModule(results);
  fs.writeFileSync(outFile, tsModule, "utf8");
  console.log("Generated", outFile);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
