#!/usr/bin/env node
const fs = require("fs");
const path = require("path");

// repo root is three levels up from packages/contract/scripts
const scriptDir = path.resolve(path.dirname(module.filename));
const repoRoot = path.resolve(scriptDir, "..", "..", "..");
const deploymentsDir = path.join(repoRoot, "packages", "contract", "ignition", "deployments");
const outDir = path.join(repoRoot, "packages", "common", "src");
const outFile = path.join(outDir, "generated_deployed_addresses.ts");

function readJsonSafe(p) {
  try {
    const raw = fs.readFileSync(p, "utf8");
    return JSON.parse(raw);
  } catch (e) {
    return null;
  }
}

function main() {
  const result = {};
  if (!fs.existsSync(deploymentsDir)) {
    console.warn("deployments dir not found:", deploymentsDir);
    fs.mkdirSync(outDir, { recursive: true });
    const tsContent =
      "// Auto-generated: no deployments found\nexport const deployedAddresses = {} as const\nexport default deployedAddresses\n;(globalThis as any).__CHAINBRAWLER_DEPLOYED_ADDRESSES__ = deployedAddresses\n";
    fs.writeFileSync(outFile, tsContent, "utf8");
    return;
  }

  const chainFolders = fs
    .readdirSync(deploymentsDir, { withFileTypes: true })
    .filter((d) => d.isDirectory())
    .map((d) => d.name);

  for (const folder of chainFolders) {
    const candidate = path.join(deploymentsDir, folder, "deployed_addresses.json");
    const data = readJsonSafe(candidate);
    if (data) {
      result[folder] = data;
    } else {
      result[folder] = {};
    }

    try {
      const journalPath = path.join(deploymentsDir, folder, "journal.jsonl");
      if (fs.existsSync(journalPath)) {
        const lines = fs
          .readFileSync(journalPath, "utf8")
          .split("\n")
          .map((l) => l.trim())
          .filter(Boolean);
        for (const line of lines) {
          try {
            const obj = JSON.parse(line);
            if (obj && obj.receipt && obj.receipt.contractAddress && obj.futureId) {
              const fid = obj.futureId;
              const addr = obj.receipt.contractAddress;
              if (!result[folder] || typeof result[folder] !== "object") result[folder] = {};
              result[folder][fid] = addr;
            }
            if (
              obj &&
              obj.type === "DEPLOYMENT_EXECUTION_STATE_COMPLETE" &&
              obj.result &&
              obj.result.address &&
              obj.futureId
            ) {
              const fid = obj.futureId;
              const addr = obj.result.address;
              if (!result[folder] || typeof result[folder] !== "object") result[folder] = {};
              result[folder][fid] = addr;
            }
          } catch (e) {
            // ignore
          }
        }
      }
    } catch (e) {
      // ignore
    }
  }

  let fbParsed;
  try {
    const fallback = path.join(repoRoot, "packages", "utils", "deployed_addresses.json");
    if (fs.existsSync(fallback)) {
      const fbRaw = fs.readFileSync(fallback, "utf8");
      fbParsed = JSON.parse(fbRaw);
      for (const [k, v] of Object.entries(fbParsed)) {
        if (!result[k]) result[k] = v;
        else {
          for (const [ik, iv] of Object.entries(v)) {
            if (!(ik in result[k])) result[k][ik] = iv;
          }
        }
      }
    }
    const expectedChains = ["chain-71", "chain-1030", "chain-2030"];
    for (const ch of expectedChains) {
      if (!result[ch]) {
        if (typeof fbParsed !== "undefined" && fbParsed && fbParsed[ch]) result[ch] = fbParsed[ch];
        else result[ch] = {};
      }
    }
  } catch (e) {
    // ignore
  }

  fs.mkdirSync(outDir, { recursive: true });
  const numericResult = {};
  for (const k of Object.keys(result)) {
    const m = String(k).match(/^chain-(\d+)$/);
    if (m) {
      numericResult[Number(m[1])] = result[k];
    } else if (!isNaN(Number(k))) {
      numericResult[Number(k)] = result[k];
    } else {
      const num = Number(k);
      if (!Number.isNaN(num)) numericResult[num] = result[k];
    }
  }

  const expectedChainsNumeric = [71, 1030, 2030];
  for (const ch of expectedChainsNumeric) {
    if (!(ch in numericResult)) numericResult[ch] = {};
  }

  const entries = Object.keys(numericResult).map((k) => {
    const v = numericResult[k];
    const formatted = JSON.stringify(v, null, 2)
      .split("\n")
      .map((l, i) => (i === 0 ? l : "  " + l))
      .join("\n");
    return `  ${k}: ${formatted}`;
  });

  const content = `// Auto-generated by packages/contract/scripts/generate_deployed_addresses.cjs\n// This file provides a TypeScript module that exports the aggregated\n// deployed addresses and also attaches them to globalThis for easy browser access.\n\nexport const deployedAddresses = {\n${entries.join(",\n")}\n} as const\n\n// Attach to globalThis to support consumers that read a runtime global\n;(globalThis as any).__CHAINBRAWLER_DEPLOYED_ADDRESSES__ = deployedAddresses\n\nexport default deployedAddresses\n`;
  fs.writeFileSync(outFile, content, "utf8");
  console.log("Wrote TypeScript deployed addresses to", outFile);
}

main();
