#!/usr/bin/env tsx
/**
 * Address Generation Script
 *
 * Generates contract addresses from the common package's deployed addresses
 * and creates a TypeScript module for the core package.
 */

import { promises as fs } from "node:fs";
import { join, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { glob } from "glob";

interface ContractAddresses {
  chainBrawler: `0x${string}`;
  leaderboardTreasury: `0x${string}`;
  leaderboardManager: `0x${string}`;
}

async function generateContractAddresses() {
  console.log("üè≠ Generating contract addresses for core package...");

  const currentDir = resolve(fileURLToPath(import.meta.url), "..");
  const coreDir = resolve(currentDir, "..");
  const outFile = join(coreDir, "src", "generated", "contractAddresses.ts");

  // Ensure generated directory exists
  await fs.mkdir(join(coreDir, "src", "generated"), { recursive: true });

  const addresses: Record<number, ContractAddresses> = {};

  // Find all deployed_addresses.json files
  const contractDir = resolve(coreDir, "..", "contract");
  const deploymentFiles = await glob("**/deployed_addresses.json", {
    cwd: join(contractDir, "ignition", "deployments"),
    absolute: true,
  });

  console.log(`Found ${deploymentFiles.length} deployment files:`, deploymentFiles);

  // Process each deployment file
  for (const deploymentFile of deploymentFiles) {
    try {
      const content = await fs.readFile(deploymentFile, "utf8");
      const deployedAddresses = JSON.parse(content);

      // Extract chain ID from the path (e.g., "chain-2030" -> 2030)
      const chainMatch = deploymentFile.match(/chain-(\d+)/);
      if (!chainMatch) {
        console.warn(`Could not extract chain ID from path: ${deploymentFile}`);
        continue;
      }

      const chainId = parseInt(chainMatch[1]);
      console.log(`Processing chain ${chainId}:`, deployedAddresses);

      // Map the deployed addresses to our interface
      const mappedAddresses: ContractAddresses = {
        chainBrawler:
          (deployedAddresses["ChainBrawlerModule#ChainBrawlerClean"] as `0x${string}`) ||
          ("0x0000000000000000000000000000000000000000" as `0x${string}`),
        leaderboardTreasury:
          (deployedAddresses["ChainBrawlerModule#LeaderboardTreasury"] as `0x${string}`) ||
          ("0x0000000000000000000000000000000000000000" as `0x${string}`),
        leaderboardManager:
          (deployedAddresses["ChainBrawlerModule#LeaderboardManager"] as `0x${string}`) ||
          ("0x0000000000000000000000000000000000000000" as `0x${string}`),
      };

      // Only add addresses if they're not all zero
      const hasValidAddresses = Object.values(mappedAddresses).some(
        (addr) => addr !== "0x0000000000000000000000000000000000000000"
      );
      if (hasValidAddresses) {
        addresses[chainId] = mappedAddresses;
        console.log(`‚úÖ Added addresses for chain ${chainId}:`, mappedAddresses);
      }
    } catch (error) {
      console.warn(`Failed to process deployment file ${deploymentFile}:`, error);
    }
  }

  // Generate TypeScript content
  const content = `// Auto-generated contract addresses
// Generated by: packages/core/scripts/generate-addresses.ts

export interface ContractAddresses {
  chainBrawler: \`0x\${string}\`;
  leaderboardTreasury: \`0x\${string}\`;
  leaderboardManager: \`0x\${string}\`;
}

export const CONTRACT_ADDRESSES = ${JSON.stringify(addresses, null, 2)} as const;

export function getContractAddresses(chainId: number): ContractAddresses {
  const addresses = CONTRACT_ADDRESSES[chainId.toString() as keyof typeof CONTRACT_ADDRESSES];
  if (!addresses) {
    throw new Error(\`Unsupported chain ID: \${chainId} as \${chainId.toString()}  \`);
  }
  return addresses;
}
`;

  await fs.writeFile(outFile, content, "utf8");
  console.log(`‚úÖ Generated contract addresses at ${outFile}`);
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  generateContractAddresses().catch(console.error);
}

export { generateContractAddresses };
